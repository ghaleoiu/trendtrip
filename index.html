<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TrendTrip | ì„œìš¸ êµ¬ ë‹¨ìœ„ ìë™ ì½”ìŠ¤ (ê°ì •Â·ì˜ˆì‚° ìµœì í™”Â·ë©€í‹°ê°ì •)</title>
  <meta name="description" content="ê°ì •Â·íŠ¸ë Œë“œÂ·ì˜ˆì‚°Â·ë‚ ì”¨ë¥¼ ë°˜ì˜í•´ ì„œìš¸ 'êµ¬' ë‹¨ìœ„ë¡œ 3ê°œì˜ ìë™ ì—¬í–‰ ì½”ìŠ¤(ìˆ™ì†Œ í¬í•¨)ë¥¼ ì œì•ˆí•©ë‹ˆë‹¤. ê°ì • í‚¤ì›Œë“œë¥¼ ì—¬ëŸ¬ ê°œ ì„ íƒí•˜ê±°ë‚˜ ì§ì ‘ ì¶”ê°€í•  ìˆ˜ ìˆì–´ìš”." />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root{ --brand:#0ea5e9 }
    html,body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif}
    .card{border-radius:1.25rem;box-shadow:0 8px 30px rgba(2,132,199,.08);padding:1rem;background:#fff}
    .btn{padding:.6rem 1rem;border-radius:.9rem;font-weight:700;transition:.12s;display:inline-flex;align-items:center;gap:.5rem}
    .btn:hover{transform:translateY(-1px)}
    .btn-primary{background:var(--brand);color:#fff}
    .btn-outline{background:#fff;border:1px solid #e5e7eb}
    .badge{padding:.22rem .55rem;border-radius:.5rem;background:#f1f5f9;font-size:.72rem}
    .pill{padding:.35rem .7rem;border:1px solid #e5e7eb;border-radius:999px;font-size:.8rem}
    .chip{border:1px solid #e5e7eb;border-radius:999px;padding:.35rem .7rem;font-size:.85rem;cursor:pointer;user-select:none}
    .chip.active{background:#0ea5e910;border-color:#0ea5e9;color:#0369a1}
    .chip.small{padding:.25rem .55rem;font-size:.78rem}
    .route-color-1{color:#0ea5e9}
    .route-color-2{color:#22c55e}
    .route-color-3{color:#f59e0b}
  </style>
</head>
<body class="bg-gradient-to-b from-sky-50 via-white to-white text-gray-800">

  <header class="sticky top-0 z-40">
    <div class="max-w-6xl mx-auto my-3 px-4 py-3 flex items-center justify-between bg-white/70 backdrop-blur rounded-xl border">
      <div class="font-extrabold text-lg flex items-center gap-2"><span class="text-2xl">ğŸ§­</span> TrendTrip</div>
      <div class="text-sm text-gray-500">ì„œìš¸ Â· êµ¬ ë‹¨ìœ„ ìë™ ì½”ìŠ¤(ê°ì •Â·ì˜ˆì‚° ìµœì í™”Â·ë©€í‹°ê°ì •)</div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 pb-10 grid md:grid-cols-3 gap-6">
    <section class="md:col-span-1 space-y-4">
      <div class="card">
        <div class="badge mb-2">ì—¬í–‰ ì„¤ì •</div>

        <label class="block text-sm mb-1">ê°ì • í‚¤ì›Œë“œ(ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)</label>
        <div id="emotionChips" class="flex flex-wrap gap-2 mb-2">
          <span data-em="íë§" class="chip">íë§</span>
          <span data-em="ì„¤ë ˜" class="chip">ì„¤ë ˜</span>
          <span data-em="ìœ„ë¡œ" class="chip">ìœ„ë¡œ</span>
          <span data-em="ëª¨í—˜" class="chip">ëª¨í—˜</span>
          <span data-em="ì‚¬ìƒ‰" class="chip">ì‚¬ìƒ‰</span>
          <span data-em="í™œë ¥" class="chip">í™œë ¥</span>
        </div>
        <div class="flex gap-2 items-center">
          <input id="emotionInput" class="flex-1 border rounded-xl px-3 py-2" placeholder="ì›í•˜ëŠ” ê°ì •ì„ ì…ë ¥ í›„ Enterë¡œ ì¶”ê°€(ìµœëŒ€ 6ê°œ)" />
          <button id="emotionClear" class="btn btn-outline">ì´ˆê¸°í™”</button>
        </div>
        <div class="mt-2 flex flex-wrap gap-2" id="emotionSelected"></div>
        <div class="text-xs text-gray-500 mt-2" id="emotionStatus">ì„ íƒëœ ê°ì •: ì—†ìŒ</div>

        <label class="block text-sm mt-4 mb-1">ì„œìš¸ êµ¬ ì„ íƒ</label>
        <select id="district" class="w-full border rounded-xl px-3 py-2">
          <option value="4"  data-center="37.5639,127.0364">ì„±ë™êµ¬</option>
          <option value="5"  data-center="37.5387,127.0822">ê´‘ì§„êµ¬</option>
          <option value="1"  data-center="37.5733,126.9793">ì¢…ë¡œêµ¬</option>
          <option value="2"  data-center="37.5636,126.9976">ì¤‘êµ¬</option>
          <option value="3"  data-center="37.5326,126.9905">ìš©ì‚°êµ¬</option>
        </select>

        <div class="grid grid-cols-2 gap-2 mt-3">
          <div>
            <label class="block text-sm mb-1">ì—¬í–‰ ìœ í˜•</label>
            <select id="tripMode" class="w-full border rounded-xl px-3 py-2">
              <option value="6h">6ì‹œê°„ ë‹¹ì¼</option>
              <option value="1n2d">1ë°• 2ì¼</option>
              <option value="2n3d">2ë°• 3ì¼</option>
            </select>
          </div>
          <div>
            <label class="block text-sm mb-1">ì´ ì˜ˆì‚°(â‚©)</label>
            <input id="budget" type="number" class="w-full border rounded-xl px-3 py-2" value="300000" />
          </div>
        </div>

        <div class="grid grid-cols-2 gap-2 mt-3">
          <div>
            <label class="block text-sm mb-1">ë‚ ì”¨</label>
            <select id="weather" class="w-full border rounded-xl px-3 py-2">
              <option value="sunny">ë§‘ìŒ</option>
              <option value="cloudy">íë¦¼</option>
              <option value="rainy">ë¹„</option>
            </select>
          </div>
          <div>
            <label class="block text-sm mb-1">ì‹¤ë‚´/ì‹¤ì™¸</label>
            <select id="inout" class="w-full border rounded-xl px-3 py-2">
              <option value="any">ìƒê´€ì—†ìŒ</option>
              <option value="indoor">ì‹¤ë‚´</option>
              <option value="outdoor">ì‹¤ì™¸</option>
            </select>
          </div>
        </div>

        <label class="text-sm flex items-center gap-2 mt-3">
          <input id="strictBudget" type="checkbox" class="scale-110"> ì˜ˆì‚° ì—„ìˆ˜
        </label>

        <div class="flex gap-2 mt-4">
          <button id="btnLoad" class="btn btn-outline">êµ¬ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°</button>
          <button id="btnGenerate" class="btn btn-primary flex-1">ì½”ìŠ¤ ìë™ ìƒì„±</button>
        </div>
        <div id="status" class="text-xs text-gray-500 mt-2">êµ¬ ì„ íƒ í›„ [êµ¬ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°] â†’ [ì½”ìŠ¤ ìë™ ìƒì„±]</div>
      </div>

      <div class="card">
        <div class="badge mb-2">ì´ì•¡ ìš”ì•½</div>
        <div id="summary" class="space-y-1 text-sm text-gray-700">
          <div>ì•¡í‹°ë¹„í‹°: -</div>
          <div>ìˆ™ë°•: -</div>
          <div class="font-semibold">í•©ê³„: -</div>
        </div>
      </div>

    </section>

    <section class="md:col-span-2 space-y-4">
      <div class="card">
        <div class="flex items-center justify-between">
          <div class="font-bold">ì§€ë„</div>
          <div class="flex gap-2 text-xs">
            <span class="pill route-color-1">ì œì•ˆ 1</span>
            <span class="pill route-color-2">ì œì•ˆ 2</span>
            <span class="pill route-color-3">ì œì•ˆ 3</span>
          </div>
        </div>
        <div id="map" class="w-full h-[420px] rounded-xl mt-2"></div>
      </div>

      <div class="grid grid-cols-1 lg:grid-cols-3 gap-4" id="proposals"></div>
    </section>
  </main>

  <script>
    const TOURAPI_PROXY = "/api/tourapi";
    const SEOUL_AREACODE = 1;
    const TARGET_UTIL = 0.95;

    let PLACES = [];
    let HOTELS = [];

    let map, layers = { markers: null, route1:null, route2:null, route3:null };
    (function initMap(){
      map = L.map('map').setView([37.5665,126.9780], 12);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'Â© OpenStreetMap'}).addTo(map);
      layers.markers = L.layerGroup().addTo(map);
    })();

    const MAX_EMOTIONS = 6;
    const selectedEmotions = new Set();

    function renderSelectedEmotions(){
      const box = document.getElementById('emotionSelected');
      box.innerHTML = '';
      if (selectedEmotions.size===0){
        document.getElementById('emotionStatus').textContent = 'ì„ íƒëœ ê°ì •: ì—†ìŒ';
        return;
      }
      document.getElementById('emotionStatus').textContent = 'ì„ íƒëœ ê°ì •: ' + Array.from(selectedEmotions).join(', ');
      Array.from(selectedEmotions).forEach(em=>{
        const span = document.createElement('span');
        span.className = 'chip small';
        span.textContent = em + ' âœ•';
        span.onclick = ()=>{ toggleEmotion(em); };
        box.appendChild(span);
      });
    }

    function toggleEmotion(em){
      if(selectedEmotions.has(em)){ selectedEmotions.delete(em); }
      else{
        if(selectedEmotions.size>=MAX_EMOTIONS){ alert('ê°ì •ì€ ìµœëŒ€ '+MAX_EMOTIONS+'ê°œê¹Œì§€ ì„ íƒí•  ìˆ˜ ìˆì–´ìš”.'); return; }
        selectedEmotions.add(em);
      }
      document.querySelectorAll('#emotionChips .chip').forEach(c=>{
        const v = c.dataset.em;
        c.classList.toggle('active', selectedEmotions.has(v));
      });
      renderSelectedEmotions();
    }

    document.getElementById('emotionChips').addEventListener('click', (e)=>{
      const chip = e.target.closest('.chip');
      if(!chip) return;
      toggleEmotion(chip.dataset.em);
    });

    document.getElementById('emotionInput').addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        const v = e.target.value.trim();
        if(!v) return;
        if(v.length>16){ alert('í‚¤ì›Œë“œëŠ” 16ì ì´í•˜ë¡œ ì…ë ¥í•´ ì£¼ì„¸ìš”.'); return; }
        toggleEmotion(v);
        e.target.value = '';
      }
    });

    document.getElementById('emotionClear').onclick = ()=>{
      selectedEmotions.clear();
      document.querySelectorAll('#emotionChips .chip').forEach(c=>c.classList.remove('active'));
      renderSelectedEmotions();
    };

    async function fetchArea(areaCode, sigunguCode, contentTypeId, numOfRows=120){
      const u = new URL(TOURAPI_PROXY, location.origin);
      u.searchParams.set("by","area");
      u.searchParams.set("areaCode", String(areaCode));
      u.searchParams.set("sigunguCode", String(sigunguCode));
      u.searchParams.set("contentTypeId", String(contentTypeId));
      u.searchParams.set("numOfRows", String(numOfRows));
      const r = await fetch(u.toString());
      const data = await r.json();
      return data?.response?.body?.items?.item || [];
    }

    function deriveThemesFromTitle(t=''){
      const tags = [];
      if (/ê³µì›|ìˆ²|ì‚°ì±…|ì²œ|í˜¸ìˆ˜|ì„¬|ì˜¤ë¦„|ë‘˜ë ˆê¸¸|ì„±ê³½ê¸¸|í•œê°•/.test(t)) tags.push('ì‚°ì±…','íë§');
      if (/íƒ€ì›Œ|ì „ë§|ìŠ¤ì¹´ì´|ë·°|í¬í† |ì•¼ê²½/.test(t)) tags.push('ë·°','ì„¤ë ˜');
      if (/ë°•ë¬¼ê´€|ë¯¸ìˆ ê´€|ì—­ì‚¬|ê¶|ì„±|ì „ì‹œ|ê¸°ë…ê´€|ë„ì„œê´€/.test(t)) tags.push('ì—­ì‚¬','ì‚¬ìƒ‰');
      if (!tags.length) tags.push('íŠ¸ë Œë“œ');
      return Array.from(new Set(tags));
    }

    function guessType(title="", ctid=""){
      const t=title||"";
      if (ctid==="14") return 'indoor';
      if (/ë°•ë¬¼ê´€|ë¯¸ìˆ ê´€|ì „ì‹œ|ê¸°ë…ê´€|ë„ì„œê´€|ê°¤ëŸ¬ë¦¬|ì•„ì¿ ì•„ë¦¬ì›€|í‚¤ì¦ˆ|VR|AR|ì‡¼í•‘ëª°|ëª°|ë°±í™”ì |ì „ë§ëŒ€/.test(t)) return 'indoor';
      if (/ê³µì›|ì‚°|ë‘˜ë ˆê¸¸|ì„±ê³½ê¸¸|ê°•|ì²œ|í˜¸ìˆ˜|ì‹œì¥|ê±°ë¦¬|ê´‘ì¥|í•œê°•|ì•¼ì™¸|ì•¼ê²½í¬ì¸íŠ¸/.test(t)) return 'outdoor';
      return 'outdoor';
    }
    function estimatePlaceCost(title="", type="outdoor", ctid=""){
      const t = title||"";
      if (ctid==="14" || /ë°•ë¬¼ê´€|ë¯¸ìˆ ê´€|ì „ì‹œ|ê¸°ë…ê´€|ì•„ì¿ ì•„ë¦¬ì›€|í”Œëœí„°ë¦¬ì›€|ê³¼í•™ê´€/.test(t)) return 8000 + Math.floor(Math.random()*12000);
      if (ctid==="28" || /ì²´í—˜|í…Œë§ˆ|VR|AR|ì¹´íŠ¸|ì„œí•‘|ì¼€ì´ë¸”ì¹´|ì „ë§ëŒ€|ìŠ¤ì¹´ì´|í”Œë¼ì‰|íŠœë¸Œ|ë³´íŠ¸|ìš”íŠ¸|ë©”íƒ€ë²„ìŠ¤/.test(t)) return 15000 + Math.floor(Math.random()*35000);
      if (/íƒ€ì›Œ|ì „ë§|Níƒ€ì›Œ|ì„œìš¸íƒ€ì›Œ|ìŠ¤ì¹´ì´|ë¼ìš´ì§€/.test(t)) return 18000 + Math.floor(Math.random()*25000);
      if (/ê³µì›|ìˆ²|ì‚°ì±…|ì²œ|ê°•|í˜¸ìˆ˜|í•´ë³€|ì˜¤ë¦„|ì‹œì¥|ê±°ë¦¬|ë‘˜ë ˆê¸¸|ì„±ê³½ê¸¸|í•œê°•/.test(t)) return Math.random()<0.5?0:2000+Math.floor(Math.random()*4000);
      if (/ê¶|ê³ ê¶|ì™•ë¦‰|ì‚¬ì°°|í•œì˜¥|ë¬¸í™”ì¬/.test(t)) return 0 + Math.floor(Math.random()*6000);
      if (/ë°±í™”ì |ì•„ìš¸ë ›|ëª°|ë”í˜„ëŒ€|í”Œë˜ê·¸ì‹­|ì‡¼í•‘|ë§ˆì¼“/.test(t)) return 0;
      return type==='indoor' ? 8000 + Math.floor(Math.random()*20000) : (Math.random()<0.6?0:3000+Math.floor(Math.random()*8000));
    }
    function estimateHotelNight(title=""){
      const t = title||"";
      if (/í¬ì‹œì¦ŒìŠ¤|ì½˜ë˜ë“œ|í•˜ì–íŠ¸|ê·¸ëœë“œ|í˜ì–´ëª¬íŠ¸|ë˜ë””ìŠ¨|JW|ë¦¬ì¸ |ì‹ ë¼í˜¸í…”|ë¡¯ë°í˜¸í…”|ì¡°ì„ íŒ°ë¦¬ìŠ¤|ì›¨ìŠ¤í‹´|ííŠ¼/.test(t))
        return 300000 + Math.floor(Math.random()*350000);
      if (/ë¦¬ì¡°íŠ¸|ìŠ¤íŒŒ|í”„ë¦¬ë¯¸ì–´|í”„ë¼ì„|í”„ë¦¬ë¯¸ì—„|ìŠ¤ìœ„íŠ¸|ì½˜ë„/.test(t))
        return 180000 + Math.floor(Math.random()*180000);
      if (/í˜¸í…”|ê´€ê´‘í˜¸í…”|ì‹œí‹°|ìŠ¤í…Œì´í˜¸í…”/.test(t))
        return 90000 + Math.floor(Math.random()*90000);
      if (/í•œì˜¥|ìŠ¤í…Œì´|íœì…˜|ê²ŒìŠ¤íŠ¸|ë¯¼ë°•|í˜¸ìŠ¤í…”/.test(t))
        return 50000 + Math.floor(Math.random()*70000);
      return 100000 + Math.floor(Math.random()*100000);
    }

    function mapItemsToPlaces(items){
      return (items||[]).map((it,idx)=>{
        const typeGuess = guessType(it.title||"", String(it.contenttypeid||""));
        return {
          id: idx+1 + (Number(it.contentid)||0),
          name: it.title,
          lat: Number(it.mapy), lng: Number(it.mapx),
          type: typeGuess,
          cost: estimatePlaceCost(it.title||"", typeGuess, String(it.contenttypeid||"")),
          themes: deriveThemesFromTitle(it.title||""),
          fomo: 70 + (idx%25)
        };
      }).filter(p=>isFinite(p.lat)&&isFinite(p.lng));
    }
    function mapItemsToHotels(items){
      return (items||[]).map((it,idx)=>({
        id: 100000 + (idx+1) + (Number(it.contentid)||0),
        name: it.title, type:"hotel",
        lat: Number(it.mapy), lng: Number(it.mapx),
        nightCost: estimateHotelNight(it.title||""),
        star: 4.0 + (idx%10)/10,
        fomo: 70 + (idx%25)
      })).filter(h=>isFinite(h.lat)&&isFinite(h.lng));
    }

    function scorePlace(p, weather){
      const fomo = p.fomo/10;
      const weatherBoost = (weather==='rainy' && p.type==='indoor') ? 6 : (weather==='sunny' && p.type==='outdoor') ? 4 : 0;
      const priceSoft = (p.cost||0) > 0 ? - ((p.cost||0) >= 30000 ? 2 : 0) : 1;
      return fomo + weatherBoost + priceSoft + 6;
    }
    function scoreHotel(h){ return (h.fomo/10) + (h.star||4); }
    function haversine(a,b){
      const R=6371; const toRad=d=>d*Math.PI/180;
      const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
      const c=2*Math.asin(Math.sqrt(s1*s1+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2));
      return R*c;
    }
    function nearestNeighborOrder(points, start){
      if(points.length<=1) return points.slice();
      const used=new Set(); let route=[]; let cur={...start};
      for(let i=0;i<points.length;i++){
        let best=null, bestD=1e9, idx=-1;
        for(let j=0;j<points.length;j++){
          if(used.has(j)) continue;
          const d=haversine(cur, points[j]);
          if(d<bestD){ bestD=d; best=points[j]; idx=j; }
        }
        used.add(idx); route.push(best); cur=best;
      }
      return route;
    }
    function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
    function seededShuffle(arr, rand){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(rand()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function uniqueBy(arr, key){ const seen=new Set(); return arr.filter(x=>{ const k=key(x); if(seen.has(k)) return false; seen.add(k); return true; }); }
    function jaccard(aIds, bIds){ const A=new Set(aIds), B=new Set(bIds); let inter=0; for(const x of A){ if(B.has(x)) inter++; } const uni = A.size + B.size - inter; return uni? inter/uni : 0; }
    const clamp = (x,lo,hi)=> Math.max(lo, Math.min(hi, x));
    function toHHMM(m){ const h=Math.floor(m/60), mm=String(m%60).padStart(2,'0'); return `${h}:${mm}` }

    function singleEmotionProfile(e){
      const base = {
        tagBoost:{}, inoutHint:"any", wantPaidRatio:0.45, premiumInclination:0.2,
        startMin:10*60, lunchMin:13*60
      };
      if(/ì„¤ë ˜|ë‘ê·¼|ì•¼ê²½|ë·°/i.test(e)) return {
        tagBoost:{ ë·°:4, ì„¤ë ˜:3, ì‚°ì±…:1, íë§:1, íŠ¸ë Œë“œ:2 }, inoutHint:"outdoor",
        wantPaidRatio:0.5, premiumInclination:0.3, startMin:11*60, lunchMin:12*60+30
      };
      if(/ìœ„ë¡œ|íœ´ì‹|í¸ì•ˆ|ì‹¤ë‚´|ì¹´í˜|ì”ì”/i.test(e)) return {
        tagBoost:{ ì‚¬ìƒ‰:3, íë§:3, ì‚°ì±…:1 }, inoutHint:"indoor",
        wantPaidRatio:0.3, premiumInclination:0.2, startMin:12*60, lunchMin:14*60
      };
      if(/ëª¨í—˜|ì•¡í‹°ë¸Œ|ì²´í—˜|ë ˆí¬ì¸ |ìŠ¤ë¦´/i.test(e)) return {
        tagBoost:{ íŠ¸ë Œë“œ:2, ë·°:1 }, inoutHint:"outdoor",
        wantPaidRatio:0.75, premiumInclination:0.45, startMin:9*60, lunchMin:13*60
      };
      if(/ì‚¬ìƒ‰|ê³ ìš”|ì—­ì‚¬|ì „ì‹œ|ë¯¸ìˆ |ë…ì„œ/i.test(e)) return {
        tagBoost:{ ì‚¬ìƒ‰:4, ì—­ì‚¬:3, íë§:1 }, inoutHint:"indoor",
        wantPaidRatio:0.4, premiumInclination:0.2, startMin:10*60+30, lunchMin:13*60
      };
      if(/í™œë ¥|ì—ë„ˆì§€|íŒŒì›Œ|í™|íŠ¸ë Œë“œ/i.test(e)) return {
        tagBoost:{ íŠ¸ë Œë“œ:4, ë·°:2, ì‚°ì±…:1 }, inoutHint:"any",
        wantPaidRatio:0.6, premiumInclination:0.35, startMin:9*60+30, lunchMin:12*60+30
      };
      if(/íë§|íœ´ì–‘|ìì—°/i.test(e)) return {
        tagBoost:{ ì‚°ì±…:4, íë§:4, ë·°:1, ì—­ì‚¬:1, ì‚¬ìƒ‰:1 }, inoutHint:"outdoor",
        wantPaidRatio:0.35, premiumInclination:0.15, startMin:10*60, lunchMin:13*60
      };
      return { ...base, tagBoost:{ íŠ¸ë Œë“œ:1 } };
    }

    function mergeEmotionProfiles(list){
      if(!list || list.length===0) return {
        name:'(ì—†ìŒ)', tagBoost:{ íŠ¸ë Œë“œ:1 }, inoutHint:'any',
        wantPaidRatio:0.45, premiumInclination:0.2, startMin:10*60, lunchMin:13*60
      };
      const profs = list.map(singleEmotionProfile);
      const sum = { tagBoost:{}, start:0, lunch:0, paid:0, prem:0, indoor:0, outdoor:0, any:0 };
      profs.forEach(p=>{
        for(const [k,v] of Object.entries(p.tagBoost||{})){
          sum.tagBoost[k] = (sum.tagBoost[k]||0)+v;
        }
        sum.start += p.startMin; sum.lunch += p.lunchMin;
        sum.paid += p.wantPaidRatio; sum.prem += p.premiumInclination;
        if(p.inoutHint==='indoor') sum.indoor++; else if(p.inoutHint==='outdoor') sum.outdoor++; else sum.any++;
      });
      const inout = (sum.indoor>sum.outdoor && sum.indoor>sum.any) ? 'indoor'
                   : (sum.outdoor>sum.indoor && sum.outdoor>sum.any) ? 'outdoor'
                   : 'any';
      const n = profs.length;
      return {
        name: list.join(', '),
        tagBoost: sum.tagBoost,
        inoutHint: inout,
        wantPaidRatio: clamp(sum.paid/n, 0.2, 0.85),
        premiumInclination: clamp(sum.prem/n, 0, 0.9),
        startMin: Math.round(sum.start/n),
        lunchMin: Math.round(sum.lunch/n)
      };
    }

    function proposalProfiles(mode, weather, inout, emotionProf){
      const hasNight = mode!=="6h";
      const emotionInOut = emotionProf.inoutHint;
      const blend = (base)=> (base==="any" ? emotionInOut : base);
      const inOutVariants = {
        1: blend(inout),
        2: inout==="any" ? (weather==="rainy"?"indoor":"outdoor") : inout,
        3: inout==="any" ? (emotionInOut==="indoor"?"indoor":"outdoor") : inout
      };
      const biases = hasNight ? ['trend_view','history_walk','premium_paid']
                              : ['walk_view','trend_indoor','premium_paid'];

      const ePaid = emotionProf.wantPaidRatio;
      const splits = hasNight
        ? [[0.45,0.55],[clamp(ePaid+0.1,0.3,0.8), 1 - clamp(ePaid+0.1,0.3,0.8)],[clamp(ePaid-0.1,0.2,0.9), 1 - clamp(ePaid-0.1,0.2,0.9)]]
        : [[1.0,0],[clamp(ePaid+0.05,0.6,1.0),clamp(0.1,0,0.4)],[clamp(ePaid,0.5,1.0),clamp(0.1,0,0.5)]];

      const starts = hasNight ? [emotionProf.startMin, emotionProf.startMin+45, Math.max(9*60, emotionProf.startMin-30)]
                              : [emotionProf.startMin, emotionProf.startMin+120, emotionProf.startMin+180];
      const lunches= hasNight ? [emotionProf.lunchMin, emotionProf.lunchMin-30, emotionProf.lunchMin+60]
                              : [emotionProf.lunchMin, emotionProf.lunchMin+90, emotionProf.lunchMin-30];

      const prem = emotionProf.premiumInclination;
      const premiumBias = [prem*0.9, prem*0.7, Math.min(0.9, prem+0.25)];

      return [1,2,3].map(i=>({
        id: i,
        bias: biases[i-1],
        inout: inOutVariants[i],
        actRatio: splits[i-1][0],
        hotelRatio: splits[i-1][1],
        startMin: starts[i-1],
        lunchMin: lunches[i-1],
        premiumInclination: premiumBias[i-1],
        emotion: emotionProf
      }));
    }

    function selectActivities(pool, conf, actBudget, maxPlaces, strict, alreadyPicked, rand){
      const eboost = (p)=>{
        let s=0;
        for(const [k,v] of Object.entries(conf.emotion.tagBoost||{})){
          if(p.themes.includes(k)) s+=v;
        }
        return s;
      };
      const tagBoost = p=>{
        let s=eboost(p);
        if(conf.bias==='trend_view'){ s += (p.themes.includes('íŠ¸ë Œë“œ')?3:0) + (p.themes.includes('ë·°')?3:0); }
        if(conf.bias==='history_walk'){ s += (p.themes.includes('ì—­ì‚¬')||p.themes.includes('ì‚¬ìƒ‰')?4:0) + (p.themes.includes('ì‚°ì±…')?2:0); }
        if(conf.bias==='premium_paid'){ s += ((p.cost||0)>0 ? 4:0) + (p.themes.includes('ë·°')?1:0); }
        if(conf.bias==='walk_view'){ s += (p.themes.includes('ì‚°ì±…')?3:0) + (p.themes.includes('ë·°')?2:0); }
        if(conf.bias==='trend_indoor'){ s += (p.themes.includes('íŠ¸ë Œë“œ')?3:0) + (p.type==='indoor'?2:0); }
        return s;
      };

      let base = pool.map(p=>({
        ...p,
        score2: scorePlace(p, window.weatherSel.value) + tagBoost(p) + (conf.inout==='any'?0:(p.type===conf.inout?2:-2))
      }));

      const pickedSet = new Set(alreadyPicked);
      base.forEach(p=>{ if(pickedSet.has(p.id)) p.score2 -= 5; });

      base = base.sort((a,b)=> b.score2 - a.score2).slice(0,160);
      base = seededShuffle(base, rand);

      const perItemCeil = maxPlaces>0
        ? Math.max(12000, Math.floor((actBudget*0.85)/maxPlaces * 1.7))
        : Infinity;

      let candidates = base.filter(p => (p.cost||0) <= perItemCeil);
      if(candidates.length < maxPlaces*1.2) candidates = base;

      const wantPaidRatio = clamp(conf.emotion.wantPaidRatio*0.5 + (conf.bias==='premium_paid'?0.4:0.0), 0.25, 0.85);
      const paid = candidates.filter(p=>(p.cost||0)>0);
      const free = candidates.filter(p=>(p.cost||0)===0);

      let targetPaid = Math.round(maxPlaces * wantPaidRatio);
      targetPaid = clamp(targetPaid, 0, maxPlaces);

      const chosen=[]; let budgetRemain = Math.floor(actBudget*0.92);

      for(const p of paid){
        if(chosen.length>=targetPaid) break;
        if(pickedSet.has(p.id)) continue;
        if((p.cost||0) <= budgetRemain){ chosen.push(p); budgetRemain -= (p.cost||0); }
      }
      const cheaper = seededShuffle(free.concat(paid.filter(p=>!chosen.includes(p)).sort((a,b)=>(a.cost||0)-(b.cost||0))), rand);
      for(const p of cheaper){
        if(chosen.length>=maxPlaces) break;
        if(pickedSet.has(p.id)) continue;
        const c = p.cost||0;
        if(c<=budgetRemain || !strict){ chosen.push(p); budgetRemain -= c; }
      }
      for(const p of base){
        if(chosen.length>=maxPlaces) break;
        if(pickedSet.has(p.id)) continue;
        chosen.push(p);
      }
      return chosen.slice(0, maxPlaces);
    }

    function selectHotels(pool, nights, hotelBudget, strict, conf, rand){
      if(nights<=0) return [];
      const perNightTarget = Math.max(90000, Math.floor(hotelBudget/nights));
      let candidates = pool
        .filter(h => (h.nightCost||0) <= perNightTarget*(conf.bias==='premium_paid'?1.6:1.25))
        .sort((a,b)=> (b.nightCost||0)-(a.nightCost||0));
      if(candidates.length===0) candidates = pool.slice().sort((a,b)=> (a.nightCost||0)-(b.nightCost||0));
      candidates = seededShuffle(candidates, rand);

      const chosen=[]; let remain = hotelBudget;
      for(const h of candidates){
        if(chosen.length>=nights) break;
        const c = h.nightCost||0;
        if(!strict || c <= remain || conf.bias==='premium_paid'){ chosen.push(h); remain -= c; }
      }
      while(chosen.length<nights){
        const cheap = pool.slice().sort((a,b)=>(a.nightCost||0)-(b.nightCost||0));
        chosen.push(cheap[chosen.length] || cheap[0]);
      }
      return chosen.slice(0,nights);
    }

    function buildTripMeta(mode){
      const nights = mode==="1n2d"?1 : mode==="2n3d"?2 : 0;
      const days = nights>0 ? nights+1 : 1;
      const perDay = nights===0 ? 3 : 4;
      const maxPlaces = days * perDay;
      return { nights, days, perDay, maxPlaces };
    }

    function buildTimeline(orderedPlaces, hotels, mode, conf, center){
      const { nights, days } = buildTripMeta(mode);
      const start = conf.startMin;
      const perSlot = (mode==="6h"? 90: 100);
      const lunch = conf.lunchMin;
      const perDay = Math.ceil(orderedPlaces.length/days);
      const blocks=[]; let idx=0;

      for(let d=0; d<days; d++){
        let t=start; blocks.push({ type:'day', label:`Day ${d+1}` });
        for(let k=0; k<perDay; k++){
          const p = orderedPlaces[idx++]; if(!p) break;
          if(t < lunch && t+perSlot >= lunch){ blocks.push({ type:'meal', time: toHHMM(lunch), name:'ì ì‹¬', cost: 15000 }); t=lunch+60; }
          blocks.push({ type:'place', time: toHHMM(t), name:p.name, cost:p.cost, lat:p.lat, lng:p.lng });
          t += perSlot;
        }
        if(d < nights && hotels[d]){
          const h = hotels[d];
          blocks.push({ type:'hotel', time:'ì²´í¬ì¸(18:00~)', name:h.name, cost:h.nightCost, lat:h.lat, lng:h.lng });
        }
      }
      return blocks;
    }

    function rebalanceToBudget(proposal, budget, center, conf, rand){
      const targetLow = Math.floor(budget*0.92), targetHigh = Math.floor(budget*0.985);
      let cur = proposal.money.total;

      if(cur < targetLow && proposal.hotels.length){
        const allHotels = HOTELS.slice().sort((a,b)=>(b.nightCost||0)-(a.nightCost||0));
        for(let i=0;i<proposal.hotels.length;i++){
          const h = proposal.hotels[i];
          const better = allHotels.find(x => (x.nightCost||0) > (h.nightCost||0) && (cur + (x.nightCost-h.nightCost)) <= targetHigh);
          if(better){ cur += (better.nightCost - h.nightCost); proposal.hotels[i] = better; }
          if(cur >= targetLow) break;
        }
      }

      if(cur < targetLow && proposal.places.length){
        const paidDesc = PLACES.filter(p=>(p.cost||0)>0).sort((a,b)=>(b.cost||0)-(a.cost||0));
        for(let i=0;i<proposal.places.length;i++){
          const p = proposal.places[i];
          const better = paidDesc.find(x => (x.cost||0) > (p.cost||0) && (cur + (x.cost-p.cost)) <= targetHigh);
          if(better){ cur += (better.cost - p.cost); proposal.places[i] = better; }
          if(cur >= targetLow) break;
        }
      }

      const extras = [
        {name:"ğŸ½ï¸ í”„ë¦¬ë¯¸ì—„ ë””ë„ˆ ì½”ìŠ¤", cost:120000},
        {name:"ğŸ’† ìŠ¤íŒŒÂ·ì‚¬ìš°ë‚˜ 2ì‹œê°„", cost:90000},
        {name:"ğŸ­ ê³µì—° VIP ì¢Œì„", cost:150000},
        {name:"ğŸŒƒ ì „ë§ëŒ€ íŒ¨ìŠ¤íŠ¸íŠ¸ë™", cost:70000},
        {name:"ğŸ›¥ï¸ í•œê°• ë³´íŠ¸/ìš”íŠ¸ ì²´í—˜", cost:130000},
        {name:"â˜• ì¹´í˜ ë””ì €íŠ¸ ì„¸íŠ¸", cost:30000},
      ];
      let tries=0;
      while(cur < targetLow && tries<10){
        const pick = extras[Math.floor(rand()*extras.length)];
        const biasLift = conf.premiumInclination>0.5 ? 1.15 : 1.0;
        const adjCost = Math.round(pick.cost * biasLift);
        if(cur + adjCost <= targetHigh){
          proposal.blocks.push({ type:'extra', time: rand()<0.5?'ì €ë…':'íœ´ì‹', name:pick.name, cost:adjCost, lat:center.lat, lng:center.lng });
          cur += adjCost;
        }
        tries++;
      }

      const actTotal = proposal.places.reduce((s,p)=>s+(p.cost||0),0)
        + proposal.blocks.filter(b=>b.type==='extra').reduce((s,b)=>s+(b.cost||0),0)
        + proposal.blocks.filter(b=>b.type==='meal').reduce((s,b)=>s+(b.cost||0),0);
      const hotelTotal = proposal.hotels.reduce((s,h)=>s+(h.nightCost||0),0);
      proposal.money = { actTotal, hotelTotal, total: actTotal + hotelTotal };
      return proposal;
    }

    function generateProposals({center, mode, budget, weather, inout, strict}){
      const { maxPlaces, nights } = buildTripMeta(mode);
      const placePool = PLACES.map(p=>({...p, score: scorePlace(p, weather)}));
      const hotelPool = HOTELS.map(h=>({...h, score: scoreHotel(h)}));

      const emotionList = Array.from(selectedEmotions);
      const eprof = mergeEmotionProfiles(emotionList);
      document.getElementById('emotionStatus').textContent =
        (emotionList.length? 'ì„ íƒëœ ê°ì •: ':'ì„ íƒëœ ê°ì •: ì—†ìŒ ') + (eprof.name||'-') +
        ` / ì„ í˜¸:${eprof.inoutHint} / ìœ ë£Œâ‰ˆ${Math.round(eprof.wantPaidRatio*100)}%`;

      const profiles = proposalProfiles(mode, weather, inout, eprof);

      const proposals = [];
      const usedIds = new Set();
      const jaccardMax = 0.6;

      profiles.forEach((conf, idx)=>{
        const seed = 131 * (idx+1) + Math.floor(budget/10000);
        const rand = mulberry32(seed);

        const hotelBudget = nights>0 ? Math.floor(budget * conf.hotelRatio) : 0;
        const actBudget   = Math.max(0, budget - hotelBudget);

        let acts = selectActivities(placePool, conf, actBudget, maxPlaces, strict, Array.from(usedIds), rand);

        for(const prev of proposals){
          let jac = jaccard(acts.map(x=>x.id), prev.places.map(x=>x.id));
          if(jac > jaccardMax){
            acts = seededShuffle(acts, rand);
            const prevSet = new Set(prev.places.map(x=>x.id));
            let replaced = 0;
            for(let i=0;i<acts.length;i++){
              if(prevSet.has(acts[i].id)){
                const candidate = placePool.find(p=>!prevSet.has(p.id) && !acts.find(a=>a.id===p.id) && p.type===acts[i].type);
                if(candidate){ acts[i] = candidate; replaced++; }
                if(replaced >= Math.ceil(maxPlaces/3)) break;
              }
            }
          }
        }

        const ordered = nearestNeighborOrder(acts, center);
        const hotels = selectHotels(hotelPool, nights, hotelBudget, strict, conf, rand);
        const blocks = buildTimeline(ordered, hotels, mode, conf, center);

        const actTotal = ordered.reduce((s,p)=>s+(p.cost||0),0)
          + blocks.filter(b=>b.type==='meal').reduce((s,b)=>s+(b.cost||0),0);
        const hotelTotal = hotels.reduce((s,h)=>s+(h.nightCost||0),0);

        const base = {
          id:conf.id, bias:conf.bias, conf,
          blocks:[...blocks],
          places:[...ordered], hotels:[...hotels],
          money:{ actTotal, hotelTotal, total: actTotal+hotelTotal }
        };

        const tuned = rebalanceToBudget(base, budget, center, conf, rand);
        proposals.push(tuned);
        ordered.slice(0, Math.ceil(maxPlaces*0.6)).forEach(p=>usedIds.add(p.id));
      });

      return proposals;
    }

    function clearRoutes(){
      ['route1','route2','route3'].forEach(k=>{ if(layers[k]){ map.removeLayer(layers[k]); layers[k]=null; }});
      layers.markers.clearLayers();
    }
    function drawProposalOnMap(prop){
      clearRoutes();
      const latlngs=[];
      prop.blocks.forEach(b=>{
        if(b.type==='place' || b.type==='hotel' || b.type==='extra'){
          if(isFinite(b.lat) && isFinite(b.lng)){
            latlngs.push([b.lat,b.lng]);
            const label = (b.type==='hotel'?'ğŸ¨ ':b.type==='extra'?'â­ ':'')+b.name;
            layers.markers.addLayer(L.marker([b.lat,b.lng]).bindPopup(label));
          }
        }
      });
      if(latlngs.length>=2){
        const style = (id)=>{
          if(id===1) return {color:'#0ea5e9', weight:5, opacity:.95};
          if(id===2) return {color:'#22c55e', weight:5, opacity:.95, dashArray:'8 6'};
          return {color:'#f59e0b', weight:5, opacity:.95, dashArray:'2 10'};
        };
        layers['route'+prop.id] = L.polyline(latlngs, style(prop.id)).addTo(map);
        map.fitBounds(layers['route'+prop.id].getBounds(), {padding:[20,20]});
      }else if(latlngs[0]){ map.setView(latlngs[0], 13); }
    }

    function renderProposals(props){
      const box = document.getElementById('proposals');
      box.innerHTML = '';
      props.forEach(p=>{
        const wrap = document.createElement('div');
        wrap.className = 'card';
        const title = p.id===1?'ì œì•ˆ 1':p.id===2?'ì œì•ˆ 2':'ì œì•ˆ 3';
        const colorClass = p.id===1?'route-color-1':p.id===2?'route-color-2':'route-color-3';

        const biasLabel = ({
          'trend_view':'íŠ¸ë Œë“œÂ·ë·°',
          'history_walk':'ì—­ì‚¬Â·ì‚°ì±…',
          'premium_paid':'í”„ë¦¬ë¯¸ì—„ ìœ ë£Œ',
          'walk_view':'ì‚°ì±…Â·ë·°',
          'trend_indoor':'íŠ¸ë Œë“œÂ·ì‹¤ë‚´'
        })[p.bias] || p.bias;

        const list = p.blocks.map(b=>{
          if(b.type==='day') return `<li class="mt-2 font-semibold">${b.label}</li>`;
          if(b.type==='meal') return `<li class="ml-4 text-gray-600">${b.time} â€¢ ${b.name} (~${(b.cost||0).toLocaleString()}ì›)</li>`;
          if(b.type==='place') return `<li class="ml-4">${b.time} â€¢ ${b.name} (~${(b.cost||0).toLocaleString()}ì›)</li>`;
          if(b.type==='hotel') return `<li class="ml-4">ğŸ¨ ${b.time} â€¢ ${b.name} (1ë°• ~${(b.cost||0).toLocaleString()}ì›)</li>`;
          if(b.type==='extra') return `<li class="ml-4">â­ ${b.time} â€¢ ${b.name} (~${(b.cost||0).toLocaleString()}ì›)</li>`;
          return '';
        }).join('');

        const ratioTxt = `${Math.round(p.conf.actRatio*100)}:${Math.round(p.conf.hotelRatio*100)}`;
        const inoutTxt = p.conf.inout==='any'?'ì‹¤ë‚´/ì™¸ í˜¼í•©':(p.conf.inout==='indoor'?'ì‹¤ë‚´ ì„ í˜¸':'ì‹¤ì™¸ ì„ í˜¸');
        const emo = p.conf.emotion?.name || '-';

        wrap.innerHTML = `
          <div class="flex items-center justify-between mb-1">
            <div class="font-bold ${colorClass}">${title}</div>
            <div class="flex items-center gap-2">
              <span class="badge">ê°ì •: ${emo}</span>
              <span class="badge">${biasLabel}</span>
              <span class="badge">${inoutTxt}</span>
              <span class="badge">ì•¡í‹°ë¹„í‹°/ìˆ™ë°• ${ratioTxt}</span>
            </div>
          </div>
          <div class="text-sm text-gray-600 mb-2">ì´ì•¡ ~${p.money.total.toLocaleString()}ì› (ì•¡í‹°ë¹„í‹° ${p.money.actTotal.toLocaleString()} + ìˆ™ë°• ${p.money.hotelTotal.toLocaleString()})</div>
          <ol class="text-sm text-gray-700">${list}</ol>
          <div class="mt-3 flex gap-2">
            <button class="btn btn-outline" data-prop="${p.id}" data-action="show">ì§€ë„ì— ë³´ê¸°</button>
            <button class="btn btn-primary" data-prop="${p.id}" data-action="adopt">ì´ ì½”ìŠ¤ ì±„íƒ</button>
          </div>
        `;
        box.appendChild(wrap);
      });

      box.querySelectorAll('button[data-action="show"]').forEach(btn=>{
        btn.onclick = ()=> {
          const id = Number(btn.dataset.prop);
          const prop = currentProposals.find(x=>x.id===id);
          if(prop) drawProposalOnMap(prop);
          updateSummary(prop.money.actTotal, prop.money.hotelTotal);
        };
      });
      box.querySelectorAll('button[data-action="adopt"]').forEach(btn=>{
        btn.onclick = ()=> {
          const id = Number(btn.dataset.prop);
          const prop = currentProposals.find(x=>x.id===id);
          if(prop){
            drawProposalOnMap(prop);
            updateSummary(prop.money.actTotal, prop.money.hotelTotal);
            alert(`${id}ë²ˆ ì½”ìŠ¤ë¥¼ ì±„íƒí–ˆìŠµë‹ˆë‹¤!`);
          }
        };
      });
    }

    function updateSummary(act, hotel){
      const el = document.getElementById('summary');
      el.innerHTML = `
        <div>ì•¡í‹°ë¹„í‹°: ~${(act||0).toLocaleString()}ì›</div>
        <div>ìˆ™ë°•: ~${(hotel||0).toLocaleString()}ì›</div>
        <div class="font-semibold">í•©ê³„: ~${((act||0)+(hotel||0)).toLocaleString()}ì›</div>
      `;
    }

    let currentCenter = { lat:37.5665, lng:126.9780 };
    let currentProposals = [];

    document.getElementById('btnLoad').onclick = async ()=>{
      const opt = document.getElementById('district').selectedOptions[0];
      const sigungu = Number(opt.value);
      const [lat,lng] = opt.dataset.center.split(',').map(Number);
      currentCenter = { lat, lng };
      document.getElementById('status').textContent = 'í•´ë‹¹ êµ¬ì˜ ì¥ì†Œ/ìˆ™ì†Œ ë¡œë”© ì¤‘â€¦';

      try{
        const [raw12, raw14, raw28, raw32] = await Promise.all([
          fetchArea(SEOUL_AREACODE, sigungu, 12, 220),
          fetchArea(SEOUL_AREACODE, sigungu, 14, 160),
          fetchArea(SEOUL_AREACODE, sigungu, 28, 160),
          fetchArea(SEOUL_AREACODE, sigungu, 32, 220),
        ]);
        PLACES = uniqueBy([
          ...mapItemsToPlaces(raw12),
          ...mapItemsToPlaces(raw14),
          ...mapItemsToPlaces(raw28),
        ], p => `${p.name}|${p.lat.toFixed(4)}|${p.lng.toFixed(4)}`);

        HOTELS = uniqueBy(mapItemsToHotels(raw32), h => `${h.name}|${h.lat.toFixed(4)}|${h.lng.toFixed(4)}`);

        document.getElementById('status').textContent = `ë¡œë“œ ì™„ë£Œ: ì¥ì†Œ ${PLACES.length} Â· ìˆ™ì†Œ ${HOTELS.length}`;
        map.setView([lat,lng], 13);
        layers.markers.clearLayers();
      }catch(e){
        console.error(e);
        document.getElementById('status').textContent = 'ë¡œë“œ ì‹¤íŒ¨(í‚¤/ì¿¼í„°/íŒŒë¼ë¯¸í„° í™•ì¸)';
      }
    };

    document.getElementById('btnGenerate').onclick = ()=>{
      if(PLACES.length===0){ alert('ë¨¼ì € [êµ¬ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°]ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.'); return; }
      const mode   = document.getElementById('tripMode').value;
      const budget = Number(document.getElementById('budget').value||0);
      const weather= document.getElementById('weather').value;
      const inout  = document.getElementById('inout').value;
      const strict = !!document.getElementById('strictBudget').checked;
      window.weatherSel = { value: weather };

      currentProposals = generateProposals({
        center: currentCenter, mode, budget, weather, inout, strict
      });
      renderProposals(currentProposals);

      drawProposalOnMap(currentProposals[0]);
      updateSummary(currentProposals[0].money.actTotal, currentProposals[0].money.hotelTotal);

      const t = currentProposals[0].money.total.toLocaleString();
      document.getElementById('status').textContent = `ì½”ìŠ¤ ìë™ ìƒì„± ì™„ë£Œ Â· ì œì•ˆ 3ì¢…(ë©€í‹° ê°ì • + ì„œë¡œ ë‹¤ë¥¸ í¸í–¥/ì˜ˆì‚°ë°°ë¶„/íƒ€ì„ë¼ì¸) Â· 1ì•ˆ ì´ì•¡ ~${t}ì› (ëª©í‘œ ${Math.round(TARGET_UTIL*100)}%)`;
    };
  </script>
</body>
</html>